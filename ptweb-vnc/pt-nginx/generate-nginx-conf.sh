#!/usr/bin/env bash
set -euo pipefail

# generate-nginx-conf.sh
# Reads the project `.env` and writes `ptweb-vnc/pt-nginx/conf/ptweb.conf`.
# Enables/disables HTTPS and a GeoIP-based blocking rule based on env variables.

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ROOT_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"
ENV_FILE="$ROOT_DIR/.env"
CONF_DIR="$SCRIPT_DIR/conf"
OUT_CONF="$CONF_DIR/ptweb.conf"

if [ -f "$ENV_FILE" ]; then
  # shellcheck disable=SC1090
  source "$ENV_FILE"
else
  echo "Warning: $ENV_FILE not found â€” using defaults"
  ENABLE_HTTPS=false
  NGINX_GEOIP_BLOCK=false
  GEOIP_BLOCK_COUNTRIES=""
  NGINX_GEOIP_ALLOW=false
  GEOIP_ALLOW_COUNTRIES=""
  SSL_CERT_PATH="/etc/ssl/certs/ssl-cert.pem"
  SSL_KEY_PATH="/etc/ssl/private/ssl-key.pem"
fi

# Normalize boolean values
ENABLE_HTTPS=${ENABLE_HTTPS:-false}
NGINX_GEOIP_BLOCK=${NGINX_GEOIP_BLOCK:-false}
GEOIP_BLOCK_COUNTRIES=${GEOIP_BLOCK_COUNTRIES:-}
NGINX_GEOIP_ALLOW=${NGINX_GEOIP_ALLOW:-false}
GEOIP_ALLOW_COUNTRIES=${GEOIP_ALLOW_COUNTRIES:-}
SSL_CERT_PATH=${SSL_CERT_PATH:-/etc/ssl/certs/ssl-cert.pem}
SSL_KEY_PATH=${SSL_KEY_PATH:-/etc/ssl/private/ssl-key.pem}

# Rate limiting defaults
NGINX_RATE_LIMIT_ENABLE=${NGINX_RATE_LIMIT_ENABLE:-false}
NGINX_RATE_LIMIT_RATE=${NGINX_RATE_LIMIT_RATE:-10r/s}   # e.g. "10r/s" or "100r/m"
NGINX_RATE_LIMIT_BURST=${NGINX_RATE_LIMIT_BURST:-20}
NGINX_RATE_LIMIT_ZONE_SIZE=${NGINX_RATE_LIMIT_ZONE_SIZE:-10m} # shared memory zone size

mkdir -p "$CONF_DIR"

echo "Generating $OUT_CONF (ENABLE_HTTPS=$ENABLE_HTTPS, NGINX_GEOIP_BLOCK=$NGINX_GEOIP_BLOCK, NGINX_GEOIP_ALLOW=$NGINX_GEOIP_ALLOW)"

# Backup existing config if present
if [ -f "$OUT_CONF" ]; then
  cp -a "$OUT_CONF" "$OUT_CONF.bak.$(date +%s)" || true
fi

render_geoip_rules() {
  # Check if either GeoIP block or allow is enabled
  geoip_enabled=false
  if [ "$NGINX_GEOIP_BLOCK" = "true" ] || [ "$NGINX_GEOIP_BLOCK" = "1" ]; then
    geoip_enabled=true
  fi
  if [ "$NGINX_GEOIP_ALLOW" = "true" ] || [ "$NGINX_GEOIP_ALLOW" = "1" ]; then
    geoip_enabled=true
  fi

  if [ "$geoip_enabled" = "true" ]; then
    cat <<EOF
    # --- GeoIP filtering section generated by generate-nginx-conf.sh ---
    geoip_country /usr/share/GeoIP/GeoIP.dat;
    geoip_proxy_recursive on;

EOF

    # Handle ALLOW mode (whitelist)
    if [ "$NGINX_GEOIP_ALLOW" = "true" ] || [ "$NGINX_GEOIP_ALLOW" = "1" ]; then
      if [ -n "$GEOIP_ALLOW_COUNTRIES" ]; then
        regex=$(echo "$GEOIP_ALLOW_COUNTRIES" | awk -F',' '{for(i=1;i<=NF;i++){if(i>1)printf"|";printf"%s",$i}}')
        cat <<EOF
    # ALLOW mode (whitelist): Only allow traffic from specified countries
    # Allowed countries: ${GEOIP_ALLOW_COUNTRIES}
    map \$geoip_country_code \$allowed_country { default 0; ~^($regex)$ 1; }
EOF
      else
        echo "    # ALLOW mode enabled but GEOIP_ALLOW_COUNTRIES is empty; no allowlist will be applied"
      fi
    # Handle BLOCK mode (blacklist)
    elif [ "$NGINX_GEOIP_BLOCK" = "true" ] || [ "$NGINX_GEOIP_BLOCK" = "1" ]; then
      if [ -n "$GEOIP_BLOCK_COUNTRIES" ]; then
        regex=$(echo "$GEOIP_BLOCK_COUNTRIES" | awk -F',' '{for(i=1;i<=NF;i++){if(i>1)printf"|";printf"%s",$i}}')
        cat <<EOF
    # BLOCK mode (blacklist): Block traffic from specified countries
    # (444 is a special nginx code that closes the connection without a response.)
    # Blocked countries: ${GEOIP_BLOCK_COUNTRIES}
    map \$geoip_country_code \$blocked_country { default 0; ~^($regex)$ 1; }
EOF
      else
        echo "    # BLOCK mode enabled but GEOIP_BLOCK_COUNTRIES is empty; no blocklist will be applied"
      fi
    fi
    echo
  fi
}

render_rate_limit_rules() {
  if [ "$NGINX_RATE_LIMIT_ENABLE" = "true" ] || [ "$NGINX_RATE_LIMIT_ENABLE" = "1" ]; then
    cat <<EOF
    # --- Rate limiting section generated by generate-nginx-conf.sh ---
    # Limit request rate per client IP using the "limit_req" module
    # Zone: pt_req_zone size: ${NGINX_RATE_LIMIT_ZONE_SIZE}, rate: ${NGINX_RATE_LIMIT_RATE}
    limit_req_zone \$binary_remote_addr zone=pt_req_zone:${NGINX_RATE_LIMIT_ZONE_SIZE} rate=${NGINX_RATE_LIMIT_RATE};

EOF
  fi
}

render_rate_limit_directive() {
  if [ "$NGINX_RATE_LIMIT_ENABLE" = "true" ] || [ "$NGINX_RATE_LIMIT_ENABLE" = "1" ]; then
    # Put limit_req near the top of the location so it applies to proxied requests
    echo "# Apply request rate limiting for this location"
    echo "limit_req zone=pt_req_zone burst=${NGINX_RATE_LIMIT_BURST} nodelay;"
  else
    :
  fi
}

render_common_server_block() {
  # Use unquoted heredoc so we can expand the optional rate-limit directive
  cat <<EOF
# Common server content (proxy settings and location blocks)
  charset utf-8;

  # Serve shared downloads with highest priority
  location ^~ /downloads/ {
    alias /shared/;
    autoindex on;
    autoindex_exact_size off;
    autoindex_localtime on;
  }

  # File manager interface
  location ^~ /files {
    rewrite ^/files/?$ /file-manager.html break;
  }

  # Root location - catches all other requests for Guacamole
  location / {
    proxy_redirect off;
    proxy_set_header Host \$host;
    proxy_set_header X-Real-IP \$remote_addr;
    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto \$scheme;

    # WebSocket support for Guacamole tunneling
    proxy_http_version 1.1;
    proxy_set_header Upgrade \$http_upgrade;
    proxy_set_header Connection "upgrade";

    client_max_body_size 10m;
    $(render_rate_limit_directive)
    client_body_buffer_size 128k;
    proxy_connect_timeout 90;
    proxy_send_timeout 90;
    proxy_read_timeout 90;
    proxy_buffers 32 4k;
    proxy_pass http://guacamole:8080/guacamole/;
  }

  location ~ \.ht {
    deny all;
  }
EOF
}

# Start writing config
{
  # Insert generated GeoIP lines (these go at http context)
  render_geoip_rules
  render_rate_limit_rules

  if [ "$ENABLE_HTTPS" = "true" ] || [ "$ENABLE_HTTPS" = "1" ]; then
    # HTTP -> HTTPS redirect server
  cat <<EOF
server {
  listen 80;
  server_name localhost;
  return 301 https://\$host\$request_uri;
}

server {
    listen 443 ssl;
    server_name localhost;

    ssl_certificate ${SSL_CERT_PATH};
    ssl_certificate_key ${SSL_KEY_PATH};

EOF
    render_common_server_block

    # If GeoIP filtering enabled, add early checks
    if [ "$NGINX_GEOIP_ALLOW" = "true" ] || [ "$NGINX_GEOIP_ALLOW" = "1" ]; then
      if [ -n "$GEOIP_ALLOW_COUNTRIES" ]; then
        echo
        echo "    # Deny requests from countries NOT in the allowlist"
        echo "    if (\$allowed_country = 0) { return 444; }"
      fi
    elif [ "$NGINX_GEOIP_BLOCK" = "true" ] || [ "$NGINX_GEOIP_BLOCK" = "1" ]; then
      if [ -n "$GEOIP_BLOCK_COUNTRIES" ]; then
        echo
        echo "    # Drop requests from blocked countries"
        echo "    if (\$blocked_country = 1) { return 444; }"
      fi
    fi

    cat <<'EOF'
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
EOF

  else
    # Plain HTTP server
    cat <<EOF
server {
    listen       80;
    server_name  localhost;

EOF
    render_common_server_block

    if [ "$NGINX_GEOIP_ALLOW" = "true" ] || [ "$NGINX_GEOIP_ALLOW" = "1" ]; then
      if [ -n "$GEOIP_ALLOW_COUNTRIES" ]; then
        echo
        echo "    # Deny requests from countries NOT in the allowlist"
        echo "    if (\$allowed_country = 0) { return 444; }"
      fi
    elif [ "$NGINX_GEOIP_BLOCK" = "true" ] || [ "$NGINX_GEOIP_BLOCK" = "1" ]; then
      if [ -n "$GEOIP_BLOCK_COUNTRIES" ]; then
        echo
        echo "    # Drop requests from blocked countries"
        echo "    if (\$blocked_country = 1) { return 444; }"
      fi
    fi

    cat <<'EOF'
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
EOF
  fi
} > "$OUT_CONF"

echo "Wrote $OUT_CONF"

exit 0
